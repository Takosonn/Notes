# IEEE standard for  Verilog

SystemVerilog是建立在IEEE Std 1364之上的。SystemVerilog提高了基于Verilog的代码的生产率、可读性和可重用性。SystemVerilog中的语言增强提供了更简洁的硬件描述，同时还提供了使用现有工具进入当前硬件实现流的简单路径。这些增强还为定向和约束随机测试台开发、覆盖驱动验证和基于断言的验证提供了广泛的支持。

本标准中使用的惯例

这个标准被组织成条款，每个条款侧重于语言的特定领域。每个子条款中都有子条款来讨论各个构造和概念。讨论从介绍和可选的构造或概念的基本原理开始，接着是语法和语义描述，接着是示例和注释。

本标准中使用的术语惯例如下：

-该词用于表示严格遵守的强制性要求，以符合标准，不允许有任何偏差（应等于要求）。

-这个词应该用来表示，在几种可能性中，有一种被推荐为特别合适，而不提及或排除其他可能性；或者某一行动方针是可取的，但不一定是必需的；或者（以否定的形式）某一行动方案被否决但不被禁止（应该等于建议）。

-may一词用于表示在标准范围内允许的行动（may等于允许的行动）。

-can一词用于陈述可能性和能力，无论是物质的、物理的还是因果的（can等于能够）。

句法描述

正文使用以下约定：

-定义术语时的斜体字体

-等宽字体，用于示例、文件名和对常量的引用，特别是0、1、x和z值

-当引用实际关键字时，Verilog和SystemVerilog关键字为粗体等宽字体

使用Backus-Naur形式（BNF）描述SystemVerilog的形式语法。

巴科斯范式 以美国人巴科斯(Backus)和丹麦人诺尔(Naur)的名字命名的一种形式化的语法表示方法，用来描述语法的一种形式体系，是一种典型的元语言。又称巴科斯-诺尔形式(Backus-Naur form)。它不仅能严格地表示语法规则，而且所描述的语法是与上下文无关的。它具有语法简单，表示明确，便于语法分析和编译的特点。BNF表示语法规则的方式为：非终结符用尖括号括起。每条规则的左部是一个非终结符，右部是由非终结符和终结符组成的一个符号串，中间一般以“：：=”分开。具有相同左部的规则可以共用一个左部，各右部之间以直竖“|”隔开。

在双引号中的字("word")代表着这些字符本身。而double_quote用来代表双引号。

在双引号外的字（有可能有下划线）代表着语法部分。

尖括号( < > )内包含的为必选项。

方括号( [ ] )内包含的为可选项。

大括号( { } )内包含的为可重复0至无数次的项。

竖线( | )表示在其左右两边任选一项，相当于"OR"的意思。

::= 是“被定义为”的意思。


使用以下约定：

-小写单词，有些包含嵌入下划线，表示语法类别。例如：

模块声明

-黑体红色字符表示保留的关键字、运算符和标点符号，作为语法的必需部分。例如：

模块=>；

-竖线（|）分隔可选项，除非它以粗体红色显示，在这种情况下，它代表自己。例如：

unary_operator ::=
+ | - | ! | ~ | & | ~& | | | ~| | ^ | ~^ | ^~

-方括号（[]）包含可选项。例如：

input_declaration ::= input [ range ] list_of_variables ;

-大括号（{}）将一个重复的项括起来，除非它以粗体红色出现，在这种情况下，它代表自己。该项可能出现零次或多次；重复从左到右，就像使用等效的左递归规则一样。因此，以下两条规则是等价的：

list_of_param_assignments ::= param_assignment { , param_assignment }
list_of_param_assignments ::=
param_assignment
| list_of_param_assignment , param_assignment

-如果任何类别的名称以斜体部分开头，则等同于没有斜体部分的类别名称。斜体部分旨在传达一些语义信息。例如，“msb_index”和“lsb_index”等同于“index”

 

本标准内容

文中简要介绍了条款和附件，以供参考。有31条和11条

附件。所有条款以及附件A至附件I均为本标准的规范性部分。附件J和

附件K仅供参考。

第1条描述了本标准的内容和本标准中使用的惯例。

第2条列出了实施本标准所需的其他标准的参考。

第3条描述SystemVerilog源文本中使用的词法标记及其约定。它描述了如何指定和解释词法标记。

第4条描述了对Verilog数据对象和数据类型的增强，包括新的变量数据对象和类型、网络数据类型扩展、字符串类型、枚举类型、用户定

义类型、结构和工会。

第5条描述SystemVerilog数组，包括打包和解包数组、动态数组、关联数组数组、队列和各种数组方法。

第6条描述了如何声明网络、变量和常量数据、关于写入变量的增强规则、信号别名和类型兼容性。

第7条描述了SystemVerilog中的面向对象编程功能。主题包括定义类，动态构造对象，继承和子类，数据隐藏和封装，多态性，

以及参数化类。

第8条描述了新的运算符、SystemVerilog数据类型的操作规则、数组上的操作，运算符方法和运算符重载。

第9条描述SystemVerilog增强的仿真调度语义。

第10条描述了对Verilog决策语句和循环结构的增强，新的过程语句、最终块、语句和块标签、增强的事件类型和事件控制。

第11条描述了用于建模组合逻辑、锁存逻辑和顺序逻辑；对Verilog连续分配的增强；过程控制。

第12条描述了对Verilog任务和函数的许多增强，以及用于导入的语法功能从一门外语和输出任务和功能到一门外语。

第13条描述了动态地生成随机数，约束随机数的生成更改约束，并植入随机数生成器（RNGs）和随机case语句执行。

第14条描述了内置的信号量和邮箱类，并描述了增强的Verilog事件类型和操作员。

第15条定义了时钟块、输入和输出偏差、周期延迟和默认时钟。

第16条描述了测试台程序的构造、测试台比赛条件的消除和程序控制任务。

第17条描述了即时断言、并发断言、属性、序列、序列操作，多锁序列、时钟解析和断言绑定。

第18条描述了覆盖组、覆盖点、交叉覆盖、覆盖选项和覆盖范围方法。

第19条描述包、编译单元（$unit)、顶级实例（$root）、嵌套模块、外部

模块、增强的端口声明、时间单位和精度、端口连接规则和名称空间。

第20条描述了接口语法、接口端口、modport、接口任务和函数，参数化接口、虚拟接口和访问接口内的对象。

第21条描述了对Verilog配置的增强。

第22条描述了对Verilog系统任务和系统功能的几个扩展，包括$typename函数，$bits size函数，range函数，数组查询函数，断言控制任

务，随机数字功能、程序控制任务、覆盖功能和对Verilog系统任务和系统功能。

第23条描述了Verilog“define and”include指令的扩展，以及用于控制关键词兼容性。

第24条描述了支持SystemVerilog数据对象的值更改转储（VCD）文件的扩展名和数据类型。

第25条涵盖了Verilog defparam语句和Verilog过程分配/取消分配语句。

第26条描述了SystemVerilog与外语的直接接口。

第27条描述了对VPI对象图的增强，以支持SystemVerilog构造。

第28条描述SystemVerilog中的断言API。

第29条描述SystemVerilog中的覆盖API。

第30条描述了对VPI的增强，以支持从文件访问设计和仿真数据。

附录A使用BNF定义了SystemVerilog的形式语法。

附件B列出了SystemVerilog关键字。

附件C描述了邮箱、信号量、随机化和进程的系统类型定义。

附录D定义了一个实现列表数据结构的列表包，类似于标准模板库（STL）。

附录E描述了SystemVerilog并发断言的形式化语义。

附录F定义了SystemVerilog DPI的C语言层。

附录G定义了用于SystemVerilog DPI应用程序的标准svdpi.h include文件。

附件H描述了在SystemVerilog中包含外语代码的通用指南申请。

附件一提供了sv vpi_user.h文件的内容列表，该文件扩展了Verilogvpi_user.h包含文件。

附录J定义了本标准中使用的术语。

附录K列出了与本标准相关的参考文件。




































## initial

所有的initial语句内的语句构成了一个initial块;

initial块从仿真0时刻开始执行，在整个仿真过程中只执行一次;

如果一个模块中包括了若干个initial块，则这些initial块从仿真0时刻开始**并发**执行;

initial

​	begin



​	end



## `timescale

timescale用来定义模块的仿真 时的时间单位和时间精度;

格式如下：

`timescale	仿真时间单位 / 时间精度

用于说明仿真时间单位和时间精度的数字只能是1、10、100不能为其它的数字;

而且时间精度不能比时间单位还要大,最多一样大;

下面定义都是对的：

`timescale 1ns/1ps

`timescale 100ns/100ns

下面的定义是错的：

`timescale 1ps/1ns

在编译过程中,timescale指令影响后面所有模块中的时延值，直至遇到另一个timescale/resetall指令;

在verilog中没有默认timescale，一个没有指定timescale的verilog模块有可能错误的继承了前面编译模块的timescale参数;



## $timeformat

$timeformat(units_number, precision_number, “suffix_string”, minimum_field_wdith);

units_number：要打印的时间单位，可写0到-15，0表示秒，-3表示毫秒，依此类推；

precision_number：要保留的小数位，默认是0；

suffix_string：可添加时间后面的字符，如“ns”；

minimum_field_wdith：字符串的最小长度，不足会补空格；

timeformat不会更改timescale设置的的时间单位与精度;

它只是更改了write、display、strobe、monitor等任务在%t格式下显示时间的方式;

在一个initial块中，它会持续生效，直到执行了另一个$timeformat;



## #

#是延迟的意思，井号后面数字是延迟的数量，延迟的单位由`timescale控制

比如有：`timescale 1ns/1ps 

意思就是时间单位为1ns，精度是1ps;

那么

#10.5 就是延迟10.5ns的意思;

在同步时序数字逻辑电路的verilog代码中，不能加入“#”进行延迟，这不是代码编写阶段能决定的;



## $display

 %b或%B    二进制 	%o或%O    八进制

d或%D    十进制  	%h或%H    十六进制

 %e或%E    实数

 %c或%C    字符	%s或%S    字符串

%v或%V    信号强度

%t或%T    时间

%M    层次实例

 \n  换行,	 \t  制表符,	\ \  反斜杠 \,	 \ "  引号”,   \%%  百分号%;

调用方式：

例如：

$display("%b + %b = %b",a,b,sum);

有displayb,displayo,$displayh的显示格式分别是二进制，八进制，十六进制



## $monitor

监测任务用于持续监测指定变量，只要这些变量发生了变化，就会立即显示对应的输出语句;

$monitor("x=%b,y=%b,cin=%b",x,y,cin);

同理，有monitor,monitorb,monitoro,$monitorh



## $stop

暂停当前仿真；



## $finish

结束当前仿真；



## latch

锁存器，在异步电路中一旦产生，就会锁住数据使输入无效；

在同步电路中，尽量避免latch的产生；

产生情况：ifelse中缺少else，case缺少default，组合逻辑中输出变量赋值给了自己；



## parameter

参数设定，定义常量，可以定义在模块内部或外部：

parameter 	name   = （位宽）常数；// 位宽默认为32位

module	modulename

#（parameter 	name   = （位宽）常数）

（  port  ）；

endmodule

子模块利用parameter定义常量，被顶层调用时默认为**子模块中参数**；

参数在实例化中演示：      

**module** adder(sum,a,b);

  parameter time_delay=5;
             ......

**adder**

#(

.time_delay(10)

)	

**ADDER**

(

. .....(.....)

 )

**endmodule**



## FSM code

### 独热码 二进制 格雷码

独热码：0001；0010；0100；1000；

二进制：00；01；10；11；

格雷码：00；01；11；10；

独热码之间只相差一位，占用较多寄存器；

二进制码位宽少，占用较多组合逻辑；

格雷码介于两者之间，对于硬件电路更优秀的存在；

如果状态小于4个就用独热码；状态多余4个使用二进制，多余24个使用格雷码；

但是在**高速**系统中，都建议使用独热码； 

### 一段式二段式三段式

一段：在一段的状态机中使用时序逻辑，既描述状态的转移又描述数据的输出；

二段：在第一段用时序逻辑描述状态的转移，在第二段用组合逻辑描述数据的输出；

三段：在第一段用时序逻辑描述状态的转移，在第二段用组合逻辑判断状态转移条件和规律，第三段输出；

一段难以描述大的状态机；

二段式与模型吻合，但是组合逻辑难以描述部分情况；

三段式是新的写法，更好且通用可识别；



## ROM_ip

文件夹创建格式

rom_宽度x总数







# 低速总线 	UART	SPI	I2C



### 1.UART

universal **asynchronous** receiver/transmitter；

他在发送数据时将并行数据转换成串行来传输，在接收时收到串行数据并转换为并行；

不需要同步时钟；

接收rx 发送tx，PC的rx连接FPGA的tx，两路连线，可实现同时收发；

#### RS232 

TXD和RXD交叉连接；

空闲状态 起始位 1 2 3 4 5 6 7 8 停止位 空闲状态   //1帧10bit；

波特率：波特率就表示每秒传出的码元数，如4800Bps，9600Bps；

比特率：指每秒传送的比特（bit）数。单位为bps；

比特率 = 波特率*每个状态对应的二进制位数；

上位机发送的起始位就是一个波特时间，还需发送一个波特时间的停止位；



### 2.SPI

串行外围设备接口，在芯片中只占用四根管脚，全双工通信；

数据传输较快，没有应答机制确认数据是否接收；

SCK：时钟信号线，用于同步通讯;         

cs_n 片选信号；

mosi，miso：数据传输；

#### flash page program: 页写

写入写使能指令，使设备处于写使能状态；

要先将要写的地方进行扇区擦除或全擦除；

先拉低片选信号，而后写入指令、三个字节的地址、数据，从串行输入D输入；

在同一页正确写入小于256个数据，否则会从第0个数据开始覆盖；

数据写入完成后一定要拉高片选信号；



### 3.I2C

空闲，起始位，数据，停止位

SCL：串行时钟线，用于同步数据；

SDA：双向串行数据线，用于通讯传输数据；

空闲状态保持高电平，每个连接到总线的设备都有独立的地址；

可以连接多个从机和多个主机，为了防止设备发生冲突，会使用仲裁；

#### EEPROM

一个IIC的器件地址，前四位地址固定可配置后三个地址，可以控制七个从设备；

最后一位R/W位，高电平为写低电平为读；

所有的从机都会收到主机发送的命令，两者对比地址，如果相同会回应一个应答位；

如果主机收到应答位，会和从机开始进行数据交互；

地址位宽有单字节和两字节，由存储空间决定；

单字节写操作：首先主机发送一个起始信号start，器件地址和R/W控制位；

从机回应一个应答信号，主设备收到应答信号，建立连接，发送字节地址，地址全部发送完发送DATA,

每发送一个地址都要发送一个应答信号，最后主机发送一个stop信号；

读操作：随机读操作和顺序读操作

每次读取一个字节，

start信号，发送器件地址，w信号，发送地址，响应信号，

再次发送一个start，发送器件地址，r信号，收到响应信号，

收到响应信号，读取data，结束发送一个无响应信号，最后主机发送stop；

顺序读操作读取的数据量多；













# 传统乘法器的改进	Multiplexer



**假设 A = 10 , B = 20, A x B ，那么时钟的消耗至少需要 20 个**

**AB = BA**

**如果被乘数小于乘数，那么被乘数和乘数互换。**

```verilog
{ Multiplier , Multiplicand } = 	
Multiplicand < Multiplier ? 	
{ Multiplicand ，Multiplier } : {Multiplier ，Multiplicand }；
```

Example

```verilog
case( i )

 0:
 begin
     isNeg <= Multiplicand[7] ^ Multiplier[7];	//due sign
     Mcand <= Multiplicand[7] ? ( ~Multiplicand + 1'b1 ) : Multiplicand; //take posetive
     Mer <= Multiplier[7] ? ( ~Multiplier + 1'b1 ) : Multiplier; 
 	Temp <= 16'd0;  //clear temp
 	i <= i + 1'b1; 
 end

 1:
 begin
     { Mcand , Mer } <= Mcand < Mer ? { Mer , Mcand } : { Mcand , Mer };	//choose the smaller to be Mer
 	i <= i + 1'b1;
 end

 2: // Multipling
 if( Mer == 0 ) i <= i + 1'b1;
 else begin Temp <= Temp + Mcand; Mer <= Mer - 1'b1; end

 3:
 begin isDone <= 1'b1; i <= i + 1'b1; end

 4:
 begin isDone <= 1'b0; i <= 3'd0; end
 
 endcase
```







# FPGA中的存储器

1.fpga上电后向存储器写入数据，这种情况下数据量大、数据值都是已知的，整个过程只需要进行一次

使用只读存储器（ROM）

2.信号源产生数据，读取数据发送数据，这种情况下数据的产生速度要大于读取速度

使用读写存储器（RAM）

3.读取数据并进行操作，要求数据能被重复使用，数据能被更改

使用FIFO

常用的存储器：

SRAM容量小

SDRAM容量大

DDR SDRAM可以在数据的上升沿和下降沿都读取信息
